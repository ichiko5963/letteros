LetterOS
最終要件定義書（叙述型・限界突破版）
序章：LetterOSは「メルマガを作るプロダクト」ではない

まず、このプロダクトの立ち位置を明確にする。

LetterOSは、メルマガを書くためのツールではない。
文章生成AIを内包してはいるが、主役はAIではない。
自動化ツールでもなければ、便利系SaaSでもない。

LetterOSは「メルマガ運用という知的作業を、構造として保存し、再利用し、進化させるOS」である。

世の中のほとんどのメルマガは、なぜ成果が出ないのか。
それは文章が下手だからでも、ノウハウが足りないからでもない。

理由は単純で、
「なぜそれが良かったのか」「なぜそれが悪かったのか」が、次に活かされていないからだ。

人間は忘れる。
感覚で判断する。
成功も失敗も、その場で消費してしまう。

LetterOSは、この“忘却”と“属人化”を構造で殺すためのプロダクトである。

第1章：LetterOSが解決する根本問題

メルマガ運用には、常に同じ破綻パターンがある。

最初は熱量が高く、時間もかける。
数通はうまくいく。
しかし次第に「何が効いているのか」が分からなくなり、
改善は感覚論になり、
やがて更新が止まる。

ここで起きている問題は、文章力の問題ではない。
運用の構造が存在しないことが問題なのだ。

LetterOSは、メルマガ運用を以下のように再定義する。

メルマガとは、
単発の文章ではなく、
「仮説 → 実行 → 観測 → 解釈 → 次回反映」
を繰り返す“知的プロセス”である。

このプロセスを、
記録し、比較し、抽象化し、再適用できる形にすること。

それがLetterOSの唯一の存在理由である。

第2章：プロダクトの中核思想 ― 人間が選び、AIが支える

LetterOSにおけるAIの立ち位置は、最初から明確に決められている。

AIは、決定しない。
AIは、代替しない。
AIは、主役にならない。

AIが行うのは、
「候補を出すこと」と「選ばれたものを最適化すること」だけである。

最初のゼロイチ。
つまり、何もない状態から「考えうる選択肢」を出す役割はAIが担う。

しかし、その中からどれを選ぶか。
その企画でいくか。
その口調でいくか。
その構成を採用するか。

それは必ず人間が決める。

なぜなら、
メルマガは「思想の発信」であり、
思想の責任はAIでは取れないからだ。

LetterOSは、
「AIに任せるプロダクト」ではなく、
**「AIと一緒に判断を積み上げるプロダクト」**として設計されている。

第3章：LetterOSの基本構造 ― プロダクト → 企画 → 通

LetterOSでは、すべてのメルマガが「プロダクト」に紐づく。

プロダクトとは、
単なる商品ではない。
**口調・思想・読者・目的が一貫した“発信主体”**の単位である。

一人の個人が、
複数のプロダクトを持つことも前提とする。

プロダクトごとに、
・どんな読者に
・どんな価値を
・どんなトーンで
届けるのかを最初に定義する。

この定義は、
すべてのAI生成の上流コンテキストとして固定される。

次に存在するのが「企画」である。

企画とは、
「今回の発信で、読者のどの認知をどう変えたいか」を定義する単位だ。

重要なのは、
企画は必ずしも1通のメルマガに対応しないという点である。

ある企画は、1通で十分かもしれない。
ある企画は、3通に分けた方がよいかもしれない。
ある企画は、5通で段階的に伝えるべきかもしれない。

ここで、AIが提案する。

「この企画は、1通よりも3通構成の方が合理的です」
「この内容は、分割しないと理解負荷が高すぎます」

ただし、
最終的に何通にするかは、必ず人間が決める。

そして、企画の中に「通（Issue）」が存在する。

通とは、
実際に配信される1通のメルマガである。

この構造により、
LetterOSは「単発」と「シリーズ」の両方を、
無理なく、同一の設計で扱える。

第4章：生成フェーズ ― AIは“案を出す存在”に徹する

生成フェーズにおいて、AIは文章を書き切らない。

AIがやるのは、
「考えうる選択肢を、過不足なく提示すること」だ。

件名は1つではない。
最低でも複数案を出す。

導入も1つではない。
論理的に入るか、感情的に入るか、問いから入るか。
複数の入口があり得る。

構成も同様だ。
結論先出しか、ストーリー型か、問題提起型か。

LetterOSでは、
すべての重要ポイントが“選択式”になる。

ユーザーは、
「書いてもらう」のではなく、
「選んでいく」。

この時点で、
すでに思考は整理され、
企画は明確になっている。

第5章：最終編集 ― AIと“ぐる”になる瞬間

選択が終わったあと、
初めてAIは「全文生成」に近いことを行う。

ただし、それは“創作”ではない。
最適化と整形である。

最終編集フェーズでAIが行うことは、極めて明確だ。

プロダクトで定義された口調に揃える。
無駄な表現を削る。
読みづらい箇所を直す。
意図しない強さ・弱さを均す。
CTAを不自然でない位置に置く。

そして、
ユーザーが「ここを変えて」と言えば、
その意図を解釈し、全文に反映する。

この時、重要なのは
AIが勝手に“良かれと思って”思想を変えないことである。

LetterOSのAIは、
編集者であって、著者ではない。

第6章：配信と予約 ― 実行も運用の一部として扱う

LetterOSは、最終的に「配信」までを運用として扱う。

配信とは、
ただ送ることではない。

いつ送るか。
どの間隔で送るか。
シリーズなら、どの順番で送るか。

これらはすべて、
結果に影響する意思決定である。

そのためLetterOSでは、
予約投稿や配信スケジュールも
“単なるオプション”ではなく、
記録され、分析される対象として扱われる。

第7章：計測 ― 数字は「判断の材料」であって、正解ではない

LetterOSが最初に重視する指標は、
開封率とクリック率である。

これらは、
メルマガというチャネルにおいて
最も現実的で、比較可能で、改善に使える指標だ。

ただし、
LetterOSは数字を「評価」ではなく
「材料」として扱う。

数字が高かったから正解、低かったから失敗、
という単純な話ではない。

重要なのは、
なぜその数字になったのかである。

第8章：PDCAの自動化 ― LetterOSが“本性”を現す領域

ここからが、LetterOSが他と決定的に違う部分だ。

LetterOSは、
配信結果を見て終わらない。

過去の配信と比較し、
平均との差を見て、
どの要素が変わったかを追い、
仮説を立てる。

件名が違ったのか。
導入が短かったのか。
CTAが強すぎたのか。
配信タイミングが悪かったのか。

これらを、
AIが言語化し、「次はこうすべきだ」と提案する。

ただし、ここでも決定はしない。
提案するだけだ。

第9章：価値パターンの抽出 ― 運用知が“資産”になる瞬間

PDCAが回り続けると、
やがて“パターン”が見えてくる。

「この口調 × この長さは開封が強い」
「この導入パターンはクリックが弱い」
「このCTAはシリーズ後半だと効かない」

LetterOSは、
これらを自動的に抽象化し、
“ルール”として保存する。

次に候補生成を行うとき、
これらのルールが自然に反映される。

こうして、
過去の成功が、未来の初期条件になる。

終章：LetterOSが最終的に作るもの

LetterOSが作りたいのは、
「うまい文章」ではない。

**「考えなくても、
ちゃんと考えた結果が出てくる環境」**である。

人間は、
迷わなくなる。
忘れなくなる。
同じ失敗を繰り返さなくなる。

そして、
メルマガという行為が、
単なる作業ではなく、
進化するプロセスになる。

LetterOS技術実証およびアーキテクチャ設計報告書：メルマガ運用を「仮説検証プロセス」へ昇華させるためのDeepResearch
概要
本報告書は、次世代型ニュースレター配信プラットフォーム「LetterOS」の構築に向けた技術的実現可能性、UI/UX構造、および最適技術スタックに関する包括的な調査結果をまとめたものである。LetterOSが掲げる「メルマガ運用を仮説検証プロセスとして構造化し、AIが選択肢提示・最適化を担い人間が決定する」という要件は、従来の単なる「作成・配信ツール」からのパラダイムシフトを意味する。このシフトを実現するためには、エディタを単なる入力インターフェースではなく、AIとの対話型実験室（ラボ）として再定義し、配信後のデータをフィードバックループとしてシステム全体に還流させる高度なアーキテクチャが不可欠である。
本調査では、ヘッドレスエディタフレームワークであるTiptap、AIストリーミングにおける業界標準Vercel AI SDK、そして詳細なイベントトラッキングを可能にするResend等の最新技術を徹底的に検証した。その結果、これらを組み合わせることで、コンテンツの生成から配信、分析、そしてモデルの自己改善に至る一連のサイクルを技術的に実装可能であることが実証された。特に、ユーザーがAIの提案を「採択」または「却下」する行動そのものをデータとして蓄積し、将来の提案精度を向上させる「人間参加型（Human-in-the-Loop）」の強化学習基盤の設計に重点を置いた。
以下に、LetterOSの核となる技術戦略、データモデル、およびユーザー体験の設計詳細を詳述する。
第1章 「仮説検証エンジン」としての運用モデル定義
1.1 現状の課題とLetterOSが目指すパラダイムシフト
従来のEメールマーケティングツール（Mailchimp, Substack等）は、本質的に「ドラフト作成 → 送信」という線形プロセスに基づいている。ユーザーはコンテンツを作成し、送信ボタンを押すが、その背後にある「なぜこの件名なのか？」「なぜこの構成なのか？」という意思決定プロセスはシステム外（ユーザーの頭の中）にあり、データとして蓄積されない。結果として、PDCAサイクル（Plan-Do-Check-Act）の「Plan（仮説）」と「Act（改善）」が分断され、属人的な運用に依存し続けている 1。
LetterOSはこの構造を根本から覆す。本システムにおいて、ニュースレターの一通一通は「実験」であり、コンテンツの各ブロックは「仮説」として扱われる。
Plan (仮説): AIが過去のパフォーマンスデータに基づき、複数のコンテンツ案（バリエーション）を提示する。
Do (実行): 人間が最適な案を選択（決定）し、配信する。
Check (検証): 配信結果（開封率、クリック率等）を、選択された特定のバリエーションに紐づけて計測する。
Act (学習): 「どの案が選ばれ、どのような成果を出したか」さらに「どの案が却下されたか」を学習し、次回の提案精度を高める。
このサイクルを実現するためには、単なるテキスト生成AIではなく、過去の文脈と成果を理解した上で提案を行う「文脈認識型AI（Context-Aware AI）」と、その提案を受け入れるための柔軟なUI構造が必要となる 2。
1.2 AIの役割：生成者から「分析的提案者」へ
LetterOSにおけるAIは、単に空白を埋める自動生成ツールではない。ユーザーの意図を汲み取り、過去のデータに基づいて戦略的な選択肢を提示する「参謀」としての役割を担う。これを実現するためには、RAG（Retrieval-Augmented Generation：検索拡張生成）アーキテクチャが不可欠である。AIは、生成を行う前にデータベース内の過去のニュースレター、そのパフォーマンス指標（開封率、CTR）、およびユーザーの過去の採択傾向を検索し、それらをコンテキストとして取り込むことで、「あなたの読者には、このトピックでは感情的な訴求よりもデータ重視のトトーンが好まれる傾向にあります」といった根拠付きの提案を行うことが可能になる 4。
第2章 フロントエンドアーキテクチャ：「選択」を促すエディタ体験
LetterOSの核心は、AIが提示する複数の選択肢（仮説）に対し、ユーザーが直感的に決定を下せるインターフェースにある。これを実現するためには、従来のリッチテキストエディタの枠を超えた技術選定が必要となる。
2.1 エディタフレームワークの選定：Tiptap (Headless ProseMirror) の優位性
Reactエコシステムにおけるリッチテキストエディタの主要な選択肢として、Tiptap、Plate.js (Slate)、Lexicalが挙げられる 6。詳細な比較検討の結果、LetterOSにはTiptapが最適であると結論付けた。
2.1.1 ヘッドレスアーキテクチャとReact NodeView
TiptapはProseMirrorをベースとしたヘッドレスエディタであり、UIを持たないため、開発者が自由にUIを設計できる点が最大の特徴である 6。特に重要なのが、React NodeView機能である。これは、エディタ内の特定のノード（段落や画像など）を、標準的なHTML要素ではなく、インタラクティブなReactコンポーネントとしてレンダリングする機能である 10。
LetterOSでは、AIが生成した複数の案を提示するために、単なるテキストの羅列ではなく、「選択カード」のようなUIコンポーネントをエディタ内に直接埋め込む必要がある。TiptapのNodeViewを使用すれば、エディタのドキュメントフローの中に「AI提案ブロック」というカスタムノードを挿入し、その中で「案A」「案B」「案C」をタブ切り替えやカルーセルで表示し、ユーザーが「採用」ボタンを押した瞬間にそのノードを通常のテキストノードに置換するといった複雑な挙動を実装できる 10。
他方、Lexical（Meta製）はパフォーマンスに優れるものの、学習曲線が急峻であり、特にネストされたコンポーザー構造が複雑であるため、初期開発速度とメンテナンス性に課題が残る 12。Plate.jsはSlateベースで柔軟性は高いが、破壊的変更が多く、コラボレーション機能の実装においてTiptap（Y.jsとの統合が強力）に劣る 6。
2.2 「仮説ブロック（Hypothesis Block）」の実装パターン
LetterOS独自のUXを実現するために、以下のカスタムノード設計を提案する。
2.2.1 HypothesisNodeの構造
このノードは、AIによる提案プロセスをカプセル化する。

JSON


{
  "type": "hypothesisBlock",
  "attrs": {
    "id": "unique-uuid",
    "prompt": "イントロダクションをより魅力的に書き直して",
    "status": "pending", // pending, generated, accepted, rejected
    "variants": [
      { "id": "v1", "content": "...", "reasoning": "緊急性を強調したパターン" },
      { "id": "v2", "content": "...", "reasoning": "ストーリーテリング重視のパターン" }
    ],
    "selectedVariantId": null
  }
}


ユーザーがAI機能を呼び出すと、エディタ上のカーソル位置にこのHypothesisBlockが挿入される 14。この時点では、エディタのドキュメントモデル上には確定したテキストは存在せず、Reactコンポーネントとしてレンダリングされた「提案インターフェース」のみが存在する。
2.2.2 ストリーミング生成とリアルタイム更新
AIからのレスポンス待ち時間はUXの摩擦となるため、Vercel AI SDKのストリーミング機能を活用する 15。AIがトークンを生成するたびに、ReactコンポーネントのPropsを通じてリアルタイムにテキストが表示される。
ここで重要な技術的課題は、ストリーミングされたコンテンツをどのようにエディタの状態（State）に反映させるかである。単純なテキスト追加ではなく、特定のHypothesisBlock内のvariants属性を更新する必要がある。これには、ProseMirrorのトランザクション機能を利用し、ノードIDをキーとしてsetNodeや属性更新を行う手法が有効である 17。
2.2.3 決定（Decision）のアクションとデータ化
ユーザーが「案B」を採用した場合、以下の処理が行われる：
HypothesisBlockノードが削除される。
その位置に、「案B」の内容を持つ標準的なparagraphノードが挿入される 10。
重要: この操作と同時に、バックエンドに対して「採用イベント」が送信される。このイベントには、「プロンプト」「生成された全バリエーション」「採用されたバリエーションID」「却下されたバリエーションID」が含まれる。これが後述するAIのファインチューニング用データセットとなる 20。
2.3 生成的UI（Generative UI）の活用
テキストだけでなく、UIそのものをAIに生成させる「Generative UI」の概念も取り入れるべきである 22。例えば、「過去の配信データを分析して」という指示に対し、AIはテキストで回答するのではなく、Reactベースのチャートコンポーネントを生成し、エディタ内に表示する。Vercel AI SDKのtool呼び出し機能を利用することで、AIがJSON形式でチャート設定を出力し、フロントエンド側でそれを動的にレンダリングすることが可能となる 15。これにより、LetterOSは単なる執筆ツールから、データ分析と可視化を兼ね備えた統合プラットフォームへと進化する。
第3章 インテリジェンスレイヤー：RAGとセマンティック検索
AIが的確な「選択肢」を提示するためには、ユーザーの過去のコンテンツとパフォーマンスデータを深く理解している必要がある。ここでは、構造化データに対応したRAGシステムの設計について詳述する。
3.1 構造化データのためのRAGアーキテクチャ
一般的なRAGは非構造化テキスト（ドキュメント等）を対象とするが、LetterOSでは「テキスト（件名・本文）」と「数値（開封率・CTR）」が密結合したデータを扱う必要がある 25。
3.1.1 ベクトル検索とメタデータフィルタリング
過去のニュースレターの件名や本文をOpenAIのtext-embedding-3-small等でベクトル化し、pgvectorを拡張機能として有効化したPostgreSQLに保存する 27。検索時には、単に意味的に近い過去記事を探すだけでなく、メタデータフィルタリングを組み合わせる。「今回のトピック（例：リモートワーク）に関連し、かつ開封率が40%を超えた過去の配信」を検索条件とする 29。
これにより、「過去に成功したパターンの踏襲」や「失敗したパターンの回避」をAIが学習し、提案理由としてユーザーに提示することが可能となる（例：「過去のデータでは、このトピックに対して疑問形の件名が高い開封率を記録しています」）。
3.2 セマンティックレイヤーとText-to-SQL
ユーザーが「先月一番クリックされたリンクは？」といった自然言語での質問を投げかけた際、AIが正確にデータベースをクエリするためには、セマンティックレイヤーの導入が推奨される 30。
LLMによる直接的なSQL生成（Text-to-SQL）は、複雑なスキーマや独自のビジネスロジック（例：「エンゲージメント率」の定義など）に対して脆弱である。セマンティックレイヤーは、ビジネス用語とデータベーススキーマのマッピングを定義し、LLMに対して「有効なクエリの作り方」をガイドする役割を果たす 32。
LangChainのSQLツールキットやVercel AI SDKのFunction Callingを使用し、事前に定義された安全なAPI経由で分析データを取得させることで、ハルシネーションを防ぎつつ、正確なデータ分析機能を提供できる 33。
3.3 フィードバックループと嗜好学習（DPO/RLHF）
LetterOSの最大の競争優位性は、ユーザーの「却下」データを活用できる点にある。通常のチャットボットでは、再生成された回答が前の回答より良いかどうかは明示されないことが多いが、LetterOSの「選択UI」では、ユーザーの選好が明確なデータとして残る 21。
この「Prompt + Generated Pairs (Winner/Loser)」のデータセットは、DPO (Direct Preference Optimization) や RLHF (Reinforcement Learning from Human Feedback) のための貴重な教師データとなる 35。
長期的には、このデータを用いてユーザーごとの微調整（Fine-Tuning）モデルを作成することが可能である。例えば、あるユーザーが常に「簡潔な言い回し」を選び、「装飾的な表現」を却下する場合、そのユーザー専用のモデルは次第に最初から簡潔な表現を生成するようになり、修正の手間を劇的に削減する。これは「Model Collapse（AI生成データのみでの学習によるモデル劣化）」を防ぐための重要な防衛策ともなる 36。
第4章 バックエンド・データエンジン：PostgreSQLを中心としたスキーマ設計
仮説検証プロセスを支えるデータ基盤には、柔軟性と堅牢性が求められる。リレーショナルデータとJSONドキュメント、そしてベクトルデータを単一のストアで扱えるPostgreSQLが最適解である 37。
4.1 データベーススキーマ設計
主要なテーブル構成案を以下に示す。

テーブル名
説明
主要カラム
技術的考察
newsletters
ニュースレターのメタデータ
id, user_id, subject, status, scheduled_at
基本的な管理情報。
newsletter_versions
コンテンツのバージョン管理
id, newsletter_id, content (JSONB), version_number, created_at
TiptapのJSON出力をそのままJSONBとして保存。バージョン管理により、AIによる変更履歴を保持 39。
hypotheses
生成された仮説と選択結果
id, newsletter_version_id, prompt, variants (JSONB), selected_variant_id, rejected_variant_ids, performance_prediction
AIの提案内容とユーザーの意思決定を記録する最重要テーブル。DPO学習データの源泉 41。
email_events
生のイベントログ
id, email_id, event_type, timestamp, metadata (JSONB)
ResendからのWebhookデータを蓄積。書き込み頻度が高いため、パーティショニングを検討 42。
analytics_aggregates
分析用集計データ
newsletter_id, variant_id, opens, clicks, updated_at
マテリアライズドビューまたは定期集計テーブル。リアルタイムダッシュボードの高速表示用 44。

4.2 高負荷イベント処理とタグ付け戦略
メール配信における分析の肝は、「どの仮説（バリエーション）が成果を出したか」を個別に追跡することである。これを実現するために、Resendの**タグ（Tags）**機能を活用する 46。
4.2.1 仮説と結果の紐付け（Roundtrip Tracking）
メール送信時、Resend APIに対して以下のようなメタデータを付与する：

JSON


{
  "from": "...",
  "to": "...",
  "subject": "Variant A: Urgency Focused",
  "tags": [
    { "name": "newsletter_id", "value": "123" },
    { "name": "hypothesis_id", "value": "hyp_456" },
    { "name": "variant_id", "value": "var_A" }
  ]
}


ユーザーがメールを開封またはクリックすると、ResendからWebhookが送信される。このペイロードには送信時に付与したタグがそのまま含まれて戻ってくる 49。システムはこのタグを読み取ることで、「この開封はVariant Aによるものだ」と特定し、対応する仮説のスコアを加算できる。これにより、A/Bテストだけでなく、通常の配信においても「どのパターンの件名が効果的だったか」を詳細に分析可能となる 49。
4.2.2 高頻度イベントのインジェスチョン（Ingestion）アーキテクチャ
数万人のリストに対しメールを配信すると、配信直後に大量のWebhook（Delivered, Opened）が発生する「スパイク」が起きる。これを同期的に処理してメインDBに書き込むと、エディタ側のパフォーマンスに悪影響を与えるリスクがある 42。
推奨されるアーキテクチャは以下の通りである：
Webhook Receiver: Next.jsのAPI RouteでWebhookを受け取り、即座にメッセージキュー（Upstash Redis, Amazon SQS等）にプッシュする 43。
Worker: バックグラウンドワーカーがキューからイベントを取り出し、バッチ処理でPostgreSQLのemail_eventsテーブルに書き込む 51。
Materialized Views: 分析画面用のデータは、email_eventsテーブルから直接集計するのではなく、マテリアライズドビューを用いて事前計算しておく。これにより、ダッシュボードの表示速度を高速に保つ 44。
第5章 インフラストラクチャと最適スタック選定
LetterOSの要件を満たすための推奨技術スタックは以下の通りである。
5.1 メールインフラ：Resendの採用
比較検討（Resend vs SendGrid vs Postmark）の結果、Resendを推奨する。
理由1：開発者体験 (DX): React Emailとの親和性が高く、モダンなSDKを提供している 53。
理由2：Webhooksの粒度: タグ情報のラウンドトリップ（送信時のメタデータをWebhookで受け取る機能）が標準でサポートされており、実装コストが低い 46。
理由3：AI親和性: Vercelのエコシステムとの統合が進んでおり、Next.js上での運用がスムーズである 50。
5.2 アプリケーションフレームワーク：Next.js (App Router)
Server Actions: エディタ（クライアント）からDB（サーバー）へのデータ保存、AI生成のトリガーをシームレスに記述できる。
Edge Runtime: AI SDKのストリーミングレスポンスを低遅延で処理するために不可欠 16。
5.3 データベース：PostgreSQL (Managed by Supabase or Neon)
JSONB: Tiptapのドキュメント構造をスキーマレスに保存しつつ、SQLで内部の特定ノードを検索可能 40。
pgvector: RAG用のベクトル検索を同一DB内で完結でき、インフラ構成を簡素化できる 28。
第6章 結論と実装ロードマップ
6.1 結論
LetterOSが目指す「仮説検証プロセスとしてのメルマガ運用」は、Tiptapの柔軟なノード設計、Vercel AI SDKによるストリーミング、Resendのタグベースイベントトラッキング、そしてPostgreSQLのJSONB/Vector機能を組み合わせることで、技術的に十分に実現可能である。
特に、ユーザーの「選択」行動をデータとして蓄積し、DPO（嗜好最適化）のループを回す設計は、単なる効率化ツールを超えた、使うほどに賢くなるSaaSとしての強力な競争優位性をもたらす。
6.2 推奨実装フェーズ
Phase 1: "The Observer"（計測基盤の構築）
Tiptapエディタの実装。
Resendを用いた配信と、タグ付けによるイベントトラッキングの実装。
PostgreSQLへのイベントログ蓄積基盤の構築。
Phase 2: "The Analyst"（AI提案機能の実装）
HypothesisBlock NodeViewの開発。
Vercel AI SDKを用いたストリーミング生成の実装。
過去データのRAG検索機能の実装。
Phase 3: "The Scientist"（自動最適化ループの確立）
ユーザーの採択/却下データのログ収集開始。
収集データに基づくプロンプトの自動改善ロジックの実装。
Generative UIによる分析ダッシュボードの対話型インターフェース化。
このアーキテクチャにより、LetterOSは「書く」ツールから「勝つための戦略を練る」プラットフォームへと進化し、メルマガ運用の新たなスタンダードを確立することができる。
補足：テーブル構造の詳細設計と技術的注記
A. Hypothesis Logs テーブルの詳細設計
AIの提案に対するユーザーのフィードバックを正確に記録するため、hypothesis_logsテーブルは以下の詳細構造を持つべきである。

SQL


CREATE TABLE hypothesis_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    newsletter_version_id UUID REFERENCES newsletter_versions(id),
    node_id VARCHAR(255) NOT NULL, -- エディタ内のノードID
    prompt_context TEXT NOT NULL, -- AIへの入力（プロンプト＋コンテキスト）
    generated_options JSONB NOT NULL, -- 生成された全バリエーション [{id, text, metadata},...]
    selected_option_id VARCHAR(255), -- ユーザーが選択したバリエーションID
    is_edited BOOLEAN DEFAULT FALSE, -- 選択後にユーザーが編集を加えたか
    final_text TEXT, -- 最終的に送信されたテキスト（編集後の正解データ）
    performance_metric FLOAT, -- 後日更新される実績値（開封率等）
    created_at TIMESTAMPTZ DEFAULT NOW()
);


このスキーマにより、「AIが何を提案し、ユーザーが何を選び、最終的にどう修正したか」という完全なトレーサビリティが確保される 21。
B. Tiptap NodeViewにおけるReact実装の注意点
ReactコンポーネントをTiptap内でレンダリングする際、エディタのレンダリングサイクルとReactのライフサイクルが競合する可能性がある。特にAIストリーミング中は頻繁に再レンダリングが発生するため、React.memoを用いたメモ化や、不要な再描画を防ぐためのステート管理（ZustandやJotaiなど、エディタ外のストアでの状態管理）が推奨される 10。また、deleteNode実行時のカーソル位置の制御（直後のノードにフォーカスを移動するなど）を細かく実装することで、UXの違和感を排除する必要がある 57。
C. マテリアライズドビューの更新戦略
リアルタイム性を担保しつつDB負荷を下げるため、pg_cron等の拡張機能を用いて、アクティブなキャンペーン（配信直後24時間以内）に関しては1分ごとのREFRESH MATERIALIZED VIEW CONCURRENTLYを実行し、それ以外の過去データに関しては1日1回の更新とするような階層的な更新戦略が有効である 44。これにより、ユーザーは配信直後の反応をほぼリアルタイムで確認できる体験が得られる。
引用文献
What is PDCA? (and Why It Matters for Marketers) - Agile Sherpas, 1月 6, 2026にアクセス、 https://www.agilesherpas.com/blog/what-is-pdca
Humans in the Loop: The Design of Interactive AI Systems | Stanford HAI, 1月 6, 2026にアクセス、 https://hai.stanford.edu/news/humans-loop-design-interactive-ai-systems
9 RAG Architectures Every AI Developer Must Know: A Complete Guide with Examples, 1月 6, 2026にアクセス、 https://pub.towardsai.net/rag-architectures-every-ai-developer-must-know-a-complete-guide-f3524ee68b9c
Build a RAG agent with LangChain, 1月 6, 2026にアクセス、 https://docs.langchain.com/oss/python/langchain/rag
Tips for Building a RAG Pipeline with NVIDIA AI LangChain AI Endpoints, 1月 6, 2026にアクセス、 https://developer.nvidia.com/blog/tips-for-building-a-rag-pipeline-with-nvidia-ai-langchain-ai-endpoints/
Plate.js vs. Tiptap: Simplicity Meets Capability, 1月 6, 2026にアクセス、 https://tiptap.dev/alternatives/plate-vs-tiptap
Which rich text editor framework should you choose in 2025? | Liveblocks blog, 1月 6, 2026にアクセス、 https://liveblocks.io/blog/which-rich-text-editor-framework-should-you-choose-in-2025
Of these three, TipTap vs Lexical vs Plate, which React WYSIWYG is best.... - Reddit, 1月 6, 2026にアクセス、 https://www.reddit.com/r/react/comments/14k1khe/of_these_three_tiptap_vs_lexical_vs_plate_which/
ueberdosis/tiptap: The headless rich text editor framework for web artisans. - GitHub, 1月 6, 2026にアクセス、 https://github.com/ueberdosis/tiptap
React node views | Tiptap Editor Docs, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/editor/extensions/custom-extensions/node-views/react
Node views | Tiptap Editor Docs, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/editor/extensions/custom-extensions/node-views
Tiptap vs Lexical: Which Rich Text Editor Should You Pick for Your Next Project? - Medium, 1月 6, 2026にアクセス、 https://medium.com/@faisalmujtaba/tiptap-vs-lexical-which-rich-text-editor-should-you-pick-for-your-next-project-17a1817efcd9
Platejs vs Tiptap : r/reactjs - Reddit, 1月 6, 2026にアクセス、 https://www.reddit.com/r/reactjs/comments/1hbiaoc/platejs_vs_tiptap/
setNode command | Tiptap Editor Docs, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/editor/api/commands/nodes-and-marks/set-node
AI SDK - AI agent tools | Tiptap Content AI, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/content-ai/capabilities/ai-toolkit/tools/ai-sdk
Streaming - Vercel, 1月 6, 2026にアクセス、 https://vercel.com/docs/functions/streaming-functions
Stream content into the editor - Tiptap, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/content-ai/capabilities/generation/text-generation/stream
Processing a ProseMirror Transaction | by Ana Chang - Medium, 1月 6, 2026にアクセス、 https://anarchang.medium.com/processing-a-prosemirror-transaction-84ce6d2c1475
simply replace a node's content in prosemirror - Stack Overflow, 1月 6, 2026にアクセス、 https://stackoverflow.com/questions/66753792/simply-replace-a-nodes-content-in-prosemirror
Building Better LLMs: A Guide to Feedback-Driven Optimisation | by Aarti Jha | Medium, 1月 6, 2026にアクセス、 https://medium.com/@aartijha96/feedback-driven-ai-the-key-to-building-better-llms-627518e364cc
Fine-Tuning Techniques - Choosing Between SFT, DPO, and RFT (With a Guide to DPO), 1月 6, 2026にアクセス、 https://cookbook.openai.com/examples/fine_tuning_direct_preference_optimization_guide
How to Build a Customer Service AI Agent with Generative UI (GenUI) in 7 Steps - Thesys, 1月 6, 2026にアクセス、 https://www.thesys.dev/blogs/build-customer-service-ai-agent-genui
Generative UI | assistant-ui, 1月 6, 2026にアクセス、 https://www.assistant-ui.com/docs/guides/ToolUI
AI SDK - Vercel, 1月 6, 2026にアクセス、 https://vercel.com/docs/ai-sdk
Chapter 1 — How to Build Accurate RAG Over Structured and Semi-structured Databases | by Madhukar Kumar | Software, AI and Marketing | Medium, 1月 6, 2026にアクセス、 https://medium.com/madhukarkumar/chapter-1-how-to-build-accurate-rag-over-structured-and-semi-structured-databases-996c68098dba
What is RAG? - Retrieval-Augmented Generation AI Explained - AWS, 1月 6, 2026にアクセス、 https://aws.amazon.com/what-is/retrieval-augmented-generation/
Advanced RAG techniques with LangChain — Part 1 | by Roberto Infante | Medium, 1月 6, 2026にアクセス、 https://medium.com/@roberto.g.infante/advanced-rag-techniques-with-langchain-f9c82290b0d1
Build Custom RAG Systems With Logic & Control | n8n Automation Platform, 1月 6, 2026にアクセス、 https://n8n.io/rag/
Which RAG optimizations gave you the best ROI - Reddit, 1月 6, 2026にアクセス、 https://www.reddit.com/r/Rag/comments/1i0mqkd/which_rag_optimizations_gave_you_the_best_roi/
RAG vs Fine-Tuning for Text-to-SQL: A Production Framework | DataBrain, 1月 6, 2026にアクセス、 https://www.usedatabrain.com/blog/rag-vs-fine-tuning
Agentic Semantic Model Improvement: Elevating Text-to-SQL Performance - Snowflake, 1月 6, 2026にアクセス、 https://www.snowflake.com/en/engineering-blog/agentic-semantic-model-text-to-sql/
Level Up Your Text-to-SQL with a Simple Semantic Layer | by Yezi Zhu | Medium, 1月 6, 2026にアクセス、 https://medium.com/@yezi.zhu/level-up-your-text-to-sql-with-a-simple-semantic-layer-983d5b58fafc
LLM & AI Models for Text-to-SQL: Modern Frameworks and Implementation Strategies, 1月 6, 2026にアクセス、 https://promethium.ai/guides/llm-ai-models-text-to-sql/
Let AI Entertain You: Increasing User Engagement with Generative AI and Rejection Sampling - arXiv, 1月 6, 2026にアクセス、 https://arxiv.org/html/2312.12457v1
13: Systems Design: How to Make LLMs Part of a Feedback Loop - Oscar Health, 1月 6, 2026にアクセス、 https://www.hioscar.ai/13-systems-design-or-how-to-make-llms-part-of-a-feedback-loop
AI model collapse: The synthetic data trap and how to avoid it - ManageEngine Insights, 1月 6, 2026にアクセス、 https://insights.manageengine.com/artificial-intelligence/ai-model-collapse-synthetic-data-trap/
PostGraphile | PostgreSQL Schema Design, 1月 6, 2026にアクセス、 https://www.graphile.org/postgraphile/postgresql-schema-design/
PostgreSQL for Data Analysis: A Complete Guide - Domo, 1月 6, 2026にアクセス、 https://www.domo.com/learn/article/postgresql-for-data-analysis-a-complete-guide
PostgreSQL as a JSON database: Advanced patterns and best practices - AWS, 1月 6, 2026にアクセス、 https://aws.amazon.com/blogs/database/postgresql-as-a-json-database-advanced-patterns-and-best-practices/
JSONB PostgreSQL: How To Store & Index JSON Data - ScaleGrid, 1月 6, 2026にアクセス、 https://scalegrid.io/blog/using-jsonb-in-postgresql-how-to-effectively-store-index-json-data-in-postgresql/
Designing Database Tables for A/B-Testing: A Practical Guide, Examples shown in PostgreSQL | by Julian | Medium, 1月 6, 2026にアクセス、 https://medium.com/@julianwitlif/designing-database-tables-for-a-b-testing-a-practical-guide-examples-shown-in-postgresql-96d6f2c7a867
Designing a Scalable Database System for High-Volume Data with Real-Time Analytics, 1月 6, 2026にアクセス、 https://medium.com/@kakarotdevv/designing-a-scalable-database-system-for-high-volume-data-with-real-time-analytics-2dbb17cb9fa1
Best Solutions for Handling High-Volume Event Tracking - Flexprice, 1月 6, 2026にアクセス、 https://flexprice.io/blog/best-solutions-for-handling-high-volume-event-tracking
Documentation: 18: 39.3. Materialized Views - PostgreSQL, 1月 6, 2026にアクセス、 https://www.postgresql.org/docs/current/rules-materializedviews.html
Optimize DB performance with materialized views and aggregated tables - Bold BI Support, 1月 6, 2026にアクセス、 https://support.boldbi.com/kb/article/14344/optimize-db-performance-with-materialized-views-and-aggregated-tables
Event Types - Resend, 1月 6, 2026にアクセス、 https://resend.com/docs/dashboard/webhooks/event-types
Send Email - Resend, 1月 6, 2026にアクセス、 https://resend.com/docs/api-reference/emails/send-email
Managing Tags - Resend, 1月 6, 2026にアクセス、 https://resend.com/docs/dashboard/emails/tags
Managing Webhooks - Resend, 1月 6, 2026にアクセス、 https://resend.com/docs/dashboard/webhooks/introduction
Capture email events with Webhooks - Resend, 1月 6, 2026にアクセス、 https://resend.com/blog/webhooks
Benchmarking PostgreSQL Batch Ingest - Tiger Data, 1月 6, 2026にアクセス、 https://www.tigerdata.com/blog/benchmarking-postgresql-batch-ingest
Optimize aggregate query on massive table to refresh materialized view - Stack Overflow, 1月 6, 2026にアクセス、 https://stackoverflow.com/questions/74118023/optimize-aggregate-query-on-massive-table-to-refresh-materialized-view
Building a Resend analytics dashboard - Tinybird, 1月 6, 2026にアクセス、 https://www.tinybird.co/blog/building-a-resend-analytics-dashboard
Migrating from SendGrid to Resend, 1月 6, 2026にアクセス、 https://resend.com/migrate/sendgrid
Documentation: 18: 8.14. JSON Types - PostgreSQL, 1月 6, 2026にアクセス、 https://www.postgresql.org/docs/current/datatype-json.html
Vue node views | Tiptap Editor Docs, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/editor/extensions/custom-extensions/node-views/vue
deleteNode command | Tiptap Editor Docs, 1月 6, 2026にアクセス、 https://tiptap.dev/docs/editor/api/commands/nodes-and-marks/delete-node
